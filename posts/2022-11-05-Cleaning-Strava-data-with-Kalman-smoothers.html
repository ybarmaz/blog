<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Yves Barmaz">
<meta name="dcterms.date" content="2022-11-05">
<meta name="description" content="A tale of mountain biking, paranormal activity and signal processing.">

<title>Yves Barmaz - Cleaning Strava data with Kalman smoothers</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Yves Barmaz</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/ybarmaz"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/YvesBarmaz"><i class="bi bi-twitter" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Cleaning Strava data with Kalman smoothers</h1>
                  <div>
        <div class="description">
          A tale of mountain biking, paranormal activity and signal processing.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">mountain biking</div>
                <div class="quarto-category">signal processing</div>
                <div class="quarto-category">tensorflow-probability</div>
                <div class="quarto-category">satellite navigation</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Yves Barmaz </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 5, 2022</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Like many cyclists and mountain bikers, I record and share my rides with <a href="https://strava.com/">Strava</a>. When I use my electric mountain bike, I normally export the relevant data to Strava from the <a href="https://www.bosch-ebike.com/en/products/ebike-flow-app">Bosch eBike Flow app</a> that controls and monitors the performance of the motor and gets geolocation data from the mobile phone. I noticed that this data is sometimes affected by measurement errors that look like weird spikes on my routes. This is visible on this screenshot of a ride I did in Morgins last summer.</p>
<div class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<p><img src="2022-11-05-Cleaning-Strava-data-with-Kalman-smoothers_files/figure-html/cell-2-output-1.jpeg" class="img-fluid"></p>
</div>
</div>
<p>To the data scientist in me who likes to correlate how much he rides week on week with the amount of ice cream he eats, this is frustrating because these errors are reflected in the total distances and elevation gains.</p>
<p>According to my satellite navigation guru friend Yannick, this can happen when the signal from a satellite bounces on cliffs before reaching the receiver, and I assume that the processing software puts strong priors on roads and trails that lead to funky corrections. For instance, the border crossing of Pas de Morgins seems to attract quite a lot of points from the nearby hillside.</p>
<div class="cell" data-execution_count="2">
<div class="cell-output cell-output-display" data-execution_count="2">
<p><img src="2022-11-05-Cleaning-Strava-data-with-Kalman-smoothers_files/figure-html/cell-3-output-1.jpeg" class="img-fluid"></p>
</div>
</div>
<p>Measurement errors can be somewhat corrected with signal processing techniques, but first we need to get the data. Strava allows you to export gpx files of your rides, which can be read with the <a href="https://pypi.org/project/gpxpy/">gpxpy</a> library. The result is a time series of latitude, longitude and elevation measurements collected every second (except when the motor automatically turns off when I spend too much time eating snacks or petting cows and alpacas), and as a preprocessing step we can normalize them.</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">'my_data/Morgins_roundtrip.gpx'</span>) <span class="im">as</span> gpx_file:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    gpx <span class="op">=</span> gpxpy.parse(gpx_file)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>route_info <span class="op">=</span> []</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> track <span class="kw">in</span> gpx.tracks:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> segment <span class="kw">in</span> track.segments:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> point <span class="kw">in</span> segment.points:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            route_info.append({</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                <span class="st">'time'</span>: point.time,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                <span class="st">'latitude'</span>: point.latitude,</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                <span class="st">'longitude'</span>: point.longitude,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                <span class="st">'elevation'</span>: point.elevation</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            })</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> normalize(series):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (series <span class="op">-</span> series[<span class="dv">0</span>])<span class="op">/</span>series.std()</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unnormalize(normalized_series, ref_series):</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> normalized_series <span class="op">*</span> ref_series.std() <span class="op">+</span> ref_series[<span class="dv">0</span>]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>route_df <span class="op">=</span> (pd.DataFrame(route_info)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            .assign(norm_lat<span class="op">=</span><span class="kw">lambda</span> x: normalize(x.latitude))</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>            .assign(norm_lon<span class="op">=</span><span class="kw">lambda</span> x: normalize(x.longitude))</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>            .assign(norm_elev<span class="op">=</span><span class="kw">lambda</span> x: normalize(x.elevation))</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>           )</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>route_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="4">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>time</th>
      <th>latitude</th>
      <th>longitude</th>
      <th>elevation</th>
      <th>norm_lat</th>
      <th>norm_lon</th>
      <th>norm_elev</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2022-07-03 10:12:15+00:00</td>
      <td>46.238541</td>
      <td>6.861996</td>
      <td>1302.3</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2022-07-03 10:12:16+00:00</td>
      <td>46.238541</td>
      <td>6.861996</td>
      <td>1302.3</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2022-07-03 10:12:17+00:00</td>
      <td>46.238670</td>
      <td>6.861501</td>
      <td>1303.2</td>
      <td>0.005734</td>
      <td>-0.017145</td>
      <td>0.003903</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2022-07-03 10:12:18+00:00</td>
      <td>46.238636</td>
      <td>6.861510</td>
      <td>1303.3</td>
      <td>0.004223</td>
      <td>-0.016833</td>
      <td>0.004336</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2022-07-03 10:12:19+00:00</td>
      <td>46.238636</td>
      <td>6.861510</td>
      <td>1303.3</td>
      <td>0.004223</td>
      <td>-0.016833</td>
      <td>0.004336</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Some of the errors like the one at Pas de Morgins seem to be characterized by the track alternating between the real underlying trajectory and a single erroneous point. If we count the occurrences of the most frequent coordinates, that point at <a href="https://geohack.toolforge.org/geohack.php?pagename=Pas_de_Morgins&amp;params=46_14_59_N_06_50_45_E_type:pass_scale:50000">Pas de Morgins</a> is precisely at the top of the list.</p>
<div class="cell" data-execution_count="5">
<div class="cell-output cell-output-display" data-execution_count="5">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>latitude</th>
      <th>longitude</th>
      <th>frequency</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>46.249691</td>
      <td>6.845940</td>
      <td>242</td>
    </tr>
    <tr>
      <th>1</th>
      <td>46.246140</td>
      <td>6.861062</td>
      <td>22</td>
    </tr>
    <tr>
      <th>2</th>
      <td>46.253025</td>
      <td>6.845210</td>
      <td>20</td>
    </tr>
    <tr>
      <th>3</th>
      <td>46.262466</td>
      <td>6.851125</td>
      <td>14</td>
    </tr>
    <tr>
      <th>4</th>
      <td>46.221539</td>
      <td>6.791507</td>
      <td>14</td>
    </tr>
    <tr>
      <th>5</th>
      <td>46.254601</td>
      <td>6.854623</td>
      <td>14</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Therefore the first obvious fix would be to exclude the most frequently repeated points and try to replace them through interpolation of the real trajectory, for instance with a <a href="https://en.wikipedia.org/wiki/Kalman_filter">Kalman filter</a>, with the added benefit of reducing measurement noise on the rest of the trajectory.</p>
<p>In the version of the Kalman filter with no control input to the dynamical system, we assume that the data is generated by a latent Markov process (the state <span class="math inline">\(z_{t+1}\)</span> at a given time step only depends on the previous step <span class="math inline">\(z_t\)</span> and not the earlier ones) with normally distributed transitions,</p>
<p><span class="math display">\[
z_{t+1} \vert z_t \sim \mathcal{N} \left( F\, z_t + b, \ \Sigma_{tr} \right),
\]</span></p>
<p>where <span class="math inline">\(F\)</span> is a (possibly time-dependent) transition matrix, <span class="math inline">\(b\)</span> a bias vector and <span class="math inline">\(\Sigma_{tr}\)</span> the covariance matrix of the transition noise. We further assume that a similar Gaussian linear process generates the observations from a given latent state,</p>
<p><span class="math display">\[
x_t \vert z_t \sim \mathcal{N} \left( H\, z_t + c, \ \Sigma_{obs} \right),
\]</span></p>
<p>where <span class="math inline">\(H\)</span> is an observation matrix, <span class="math inline">\(c\)</span> a bias term and <span class="math inline">\(\Sigma_{obs}\)</span> the covariance of the observation process.</p>
<p>With these strong assumptions of normality and linear transformations, the posterior distribution of the latent states given observations can be derived through linear algebra operations. These operations are readily implemented in the <a href="https://www.tensorflow.org/probability/api_docs/python/tfp/distributions/LinearGaussianStateSpaceModel"><code>tfd.LinearGaussianStateSpaceModel</code> distribution</a> in the TensorFlow Probability library. The <code>forward_filter</code> method runs a Kalman filter to compute the filtered marginal distribution <span class="math inline">\(P(z_t \vert x_{1..t})\)</span> conditioned only on past observations, and the <code>posterior_marginal</code> method runs a Kalman smoother to compute the filtered marginal distribution <span class="math inline">\(P(z_t \vert x_{1..T})\)</span> conditioned on the full history of observations, including the future ones. These algorithms are discussed in details in section 8.3 of <a href="https://probml.github.io/pml-book/book2.html">Probabilistic Machine Learning: Advanced Topics</a>. Since we have access to the whole GPS track, we will of course use the Kalman smoother. Conveniently, these methods also work if we condition only on a subset of the observations. Which observations should be ignored can be specified with an optional <code>mask</code> argument.</p>
<p>The first <a href="https://www.tensorflow.org/probability/api_docs/python/tfp/distributions/LinearGaussianStateSpaceModel#examples">example</a> in the official TensorFlow Probability documentation is precisely the tracking problem that interests us, where the latent space is the real position and the observation is the noisy measurement. Here we will increase the dimension of the latent space and add a velocity vector <span class="math inline">\(\mathbf{v}\)</span> and an acceleration vector <span class="math inline">\(\mathbf{a}\)</span> to the true position <span class="math inline">\(\mathbf{s} = (latitude, longitude, elevation)\)</span>, so that <span class="math inline">\(z = (\mathbf{s}, \mathbf{v}, \mathbf{a})\)</span>, and use transitions inspired by classical mechanics,</p>
<p><span class="math display">\[
z_{t+1} \vert z_t \sim \mathcal{N} \left( (\mathbf{s}_t + \mathbf{v}_t, \mathbf{v}_t + \mathbf{a}_t, 0), \Sigma_{tr} \right),
\]</span></p>
<p>with a diagonal transition covariance matrix <span class="math inline">\(\Sigma_{tr}\)</span> that carries much more uncertainty in its acceleration components. This kind of model is useful to estimate the velocity and acceleration solely from the position measurements (simply taking finite differences would be very inaccurate given the measurement noise), and it also incorporates knowledge from the laws of physics on how past states are going to influence future states. In a nutshell, it assumes that the forces affecting the bike and its rider are subject to random changes (I can brake, accelerate or turn, or collide with external obstacles), and my velocity and position are going to be a solution to Newton’s second law of motion (<span class="math inline">\(F = ma\)</span>). Such a model can extrapolate the future position from the current velocity, and correct the velocity and acceleration estimations from the measured positions.</p>
<p>Note that to estimate the physical velocity and acceleration, it would be better to transform the spherical coordinates into cartesian coordinates, but for our purpose of error correction, it should be good enough to use the (locally normalized) spherical ones.</p>
<div class="cell" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify a Kalman filter</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>ndims <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>noise_std <span class="op">=</span> <span class="fl">.2</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>n_steps <span class="op">=</span> <span class="bu">len</span>(route_df)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> tfd.LinearGaussianStateSpaceModel(</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  num_timesteps<span class="op">=</span>n_steps,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  transition_matrix<span class="op">=</span>(tf.linalg.diag(<span class="dv">2</span><span class="op">*</span>ndims<span class="op">*</span>[<span class="fl">1.</span>] <span class="op">+</span> ndims<span class="op">*</span>[<span class="fl">0.</span>])</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                     <span class="op">+</span> tf.pad(tf.eye(<span class="dv">2</span> <span class="op">*</span> ndims),</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                              tf.constant([[<span class="dv">0</span>, ndims],</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                                           [ndims, <span class="dv">0</span>]]))),</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  transition_noise<span class="op">=</span>tfd.MultivariateNormalDiag(</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>   scale_diag<span class="op">=</span>tf.concat([<span class="fl">1e-9</span> <span class="op">*</span> tf.ones([ndims]),</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                         <span class="fl">1e-9</span> <span class="op">*</span> tf.ones([ndims]),</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                         <span class="fl">3e-2</span> <span class="op">*</span> tf.ones([ndims])],</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                        axis<span class="op">=</span><span class="dv">0</span>)),</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  observation_matrix<span class="op">=</span>tf.pad(tf.eye(ndims),</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                            tf.constant([[<span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                                         [<span class="dv">0</span>, <span class="dv">2</span><span class="op">*</span>ndims]])),</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  observation_noise<span class="op">=</span>tfd.MultivariateNormalDiag(</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>   scale_diag<span class="op">=</span>noise_std <span class="op">*</span> tf.ones([ndims])),</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  initial_state_prior<span class="op">=</span>tfd.MultivariateNormalDiag(</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>   scale_diag<span class="op">=</span><span class="fl">1e-9</span> <span class="op">*</span> tf.ones([<span class="dv">3</span><span class="op">*</span>ndims])))</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Collect the observations into a tensor</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> tf.convert_to_tensor(</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    route_df.loc[:n_steps<span class="op">-</span><span class="dv">1</span>, [<span class="st">'norm_lon'</span>, <span class="st">'norm_lat'</span>, <span class="st">'norm_elev'</span>]].values,</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    dtype<span class="op">=</span>tf.float32)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify a mask to ignore measurements that occur more than 10 times</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>maximum_accepted_frequency <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>rejected_df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    route_df.groupby([<span class="st">'latitude'</span>, <span class="st">'longitude'</span>])[<span class="st">'time'</span>].count()</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">&gt;</span>maximum_accepted_frequency</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>rejected_df.columns <span class="op">=</span> [<span class="st">'masked'</span>]</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>frequency_mask <span class="op">=</span> route_df.merge(rejected_df,</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>                                how<span class="op">=</span><span class="st">'left'</span>,</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>                                left_on<span class="op">=</span>[<span class="st">'latitude'</span>, <span class="st">'longitude'</span>],</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>                                right_index<span class="op">=</span><span class="va">True</span>)[<span class="st">'masked'</span>]</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Run a smoothing recursion to extract posterior marginals for locations</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="co"># at previous timesteps while rejecting the repeated measurements</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>posterior_means, posterior_covs <span class="op">=</span> model.posterior_marginals(x,</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>                                                            mask<span class="op">=</span>frequency_mask)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>If we overlap the observed time series of normalized geographic coordinates with the filtered ones, it appears that the solid blocks on the observed values that correspond to the back and forth patterns do get corrected by the Kalman smoothing with masked repeated values.</p>
<div class="cell" data-execution_count="7">
<div class="cell-output cell-output-display">
<p><img src="2022-11-05-Cleaning-Strava-data-with-Kalman-smoothers_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The spikes caused by isolated errors are a bit attenuated by the filter, provided the observation noise scale parameter is large enough. If it is too small, extreme points are interpreted as legitimate measurements because they are unlikely to be observation errors under the model specifications. But too large a scale parameter blurs out the inferred trajectory as it cannot resolve the trail geometry.</p>
<div class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">
<p><img src="2022-11-05-Cleaning-Strava-data-with-Kalman-smoothers_files/figure-html/cell-9-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>So the trick is to run a first Kalman smoother with an observation noise scale parameter that is large enough to identify the individual outliers (while masking the repeated measurements that we already identified), followed by a second one with lower noise while masking the individual outliers in addition to the repeated measurements to infer the true trajectory. The identification of individual outliers after the first smoothing can be achieved by measuring the distance between the observations and the posterior mean of the first Kalman smoother, and rejecting the observations that are beyond a certain threshold.</p>
<div class="cell" data-execution_count="9">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the distance (Euclidean distance in the space of normalized</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># coordinates) and set a mask beyond a threshold of 0.02</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>threshold <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>filtered_lon <span class="op">=</span> posterior_means[:,<span class="dv">0</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>filtered_lat <span class="op">=</span> posterior_means[:,<span class="dv">1</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>filtered_elev <span class="op">=</span> posterior_means[:,<span class="dv">2</span>]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> np.sqrt((route_df[<span class="st">'norm_lon'</span>] <span class="op">-</span> filtered_lon)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">+</span>(route_df[<span class="st">'norm_lat'</span>] <span class="op">-</span> filtered_lat)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">+</span>(route_df[<span class="st">'norm_elev'</span>] <span class="op">-</span> filtered_elev)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>               )</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>distance_mask <span class="op">=</span> delta <span class="op">&gt;</span> threshold</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co"># specify a second Kalman smoother with a lower noise parameter</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>noise_std_2 <span class="op">=</span> <span class="fl">.05</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>model2 <span class="op">=</span> tfd.LinearGaussianStateSpaceModel(</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>  num_timesteps<span class="op">=</span>n_steps,</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>  transition_matrix<span class="op">=</span>(tf.linalg.diag(<span class="dv">2</span><span class="op">*</span>ndims<span class="op">*</span>[<span class="fl">1.</span>] <span class="op">+</span> ndims<span class="op">*</span>[<span class="fl">0.</span>])</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> tf.pad(tf.eye(<span class="dv">2</span> <span class="op">*</span> ndims), tf.constant([[<span class="dv">0</span>, ndims],[ndims, <span class="dv">0</span>]]))),</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  transition_noise<span class="op">=</span>tfd.MultivariateNormalDiag(</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>   scale_diag<span class="op">=</span>tf.concat([<span class="fl">1e-9</span> <span class="op">*</span> tf.ones([ndims]),</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>                         <span class="fl">1e-9</span> <span class="op">*</span> tf.ones([ndims]),</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>                         <span class="fl">3e-2</span> <span class="op">*</span> tf.ones([ndims])], axis<span class="op">=</span><span class="dv">0</span>)),</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  observation_matrix<span class="op">=</span>tf.pad(tf.eye(ndims), tf.constant([[<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">2</span><span class="op">*</span>ndims]])),</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>  observation_noise<span class="op">=</span>tfd.MultivariateNormalDiag(</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>   scale_diag<span class="op">=</span>noise_std_2 <span class="op">*</span> tf.ones([ndims])),</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>  initial_state_prior<span class="op">=</span>tfd.MultivariateNormalDiag(</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>   scale_diag<span class="op">=</span><span class="fl">1e-9</span> <span class="op">*</span> tf.ones([<span class="dv">3</span><span class="op">*</span>ndims])))</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="co"># apply the smoother with the combined masks</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>corrected_posterior_means, corrected_posterior_covs <span class="op">=</span> (</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    model2.posterior_marginals(x, mask<span class="op">=</span>frequency_mask<span class="op">+</span>distance_mask))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The posterior mean of the second smoother produces a clean estimation of the real trajectory, free of any weird spike. As a last step, we can rescale it and plot it on OpenStreetMap to admire the result and think of future bike rides!</p>
<div class="cell" data-execution_count="10">
<div class="cell-output cell-output-display" data-execution_count="10">

        <iframe width="750" height="600" src="my_data/map.html" frameborder="0" allowfullscreen=""></iframe>
        
</div>
</div>
<section id="acknowledgement" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgement">Acknowledgement</h2>
<p>I would like to thank Maxime Baillifard for showing me his hometrails around Morgins, an area that seems to affect GPS signals like the Bermuda Triangle, and Yannick Stebler for providing a rational explanation about signals bouncing on cliffs that debunked that myth.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>